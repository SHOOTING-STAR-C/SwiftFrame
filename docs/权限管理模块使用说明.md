# SwiftFrame 权限管理模块使用说明

## 概述

SwiftFrame 权限管理模块提供了完整的基于角色和权限的访问控制（RBAC）功能，支持超级管理员和普通用户两种角色。

## 角色说明

### 1. 超级管理员 (ROLE_SUPER_ADMIN)

- **描述**: 超级管理员，拥有所有权限
- **权限**: 拥有系统中所有权限，可以访问所有资源和功能
- **适用场景**: 系统管理员、运维人员

### 2. 普通用户 (ROLE_USER)

- **描述**: 普通用户，拥有基本权限
- **权限**: 拥有基本的业务数据读取、创建和更新权限
- **适用场景**: 普通业务用户

## 权限分类

### 用户管理权限

| 权限标识 | 描述 |
|---------|------|
| `user:read` | 查看用户列表 |
| `user:create` | 创建用户 |
| `user:update` | 更新用户信息 |
| `user:delete` | 删除用户 |
| `user:reset_password` | 重置用户密码 |
| `user:lock` | 锁定/解锁用户账户 |

### 角色管理权限

| 权限标识 | 描述 |
|---------|------|
| `role:read` | 查看角色列表 |
| `role:create` | 创建角色 |
| `role:update` | 更新角色信息 |
| `role:delete` | 删除角色 |
| `role:grant_authority` | 分配权限给角色 |
| `role:revoke_authority` | 收回角色权限 |

### 权限管理权限

| 权限标识 | 描述 |
|---------|------|
| `authority:read` | 查看权限列表 |
| `authority:create` | 创建权限 |
| `authority:update` | 更新权限信息 |
| `authority:delete` | 删除权限 |

### 业务数据权限

| 权限标识 | 描述 |
|---------|------|
| `data:read` | 查看业务数据 |
| `data:create` | 创建业务数据 |
| `data:update` | 更新业务数据 |
| `data:delete` | 删除业务数据 |
| `data:export` | 导出数据 |
| `data:import` | 导入数据 |

### 系统管理权限

| 权限标识 | 描述 |
|---------|------|
| `system:read` | 查看系统配置 |
| `system:update` | 更新系统配置 |
| `log:read` | 查看系统日志 |
| `log:delete` | 清理系统日志 |

## 默认用户

系统初始化时会创建两个默认用户：

### 超级管理员

- **用户名**: `admin`
- **密码**: `admin123`
- **角色**: ROLE_SUPER_ADMIN
- **邮箱**: admin@swift.com

⚠️ **注意**: 首次登录后请立即修改默认密码！

### 普通用户

- **用户名**: `user`
- **密码**: `user123`
- **角色**: ROLE_USER
- **邮箱**: user@swift.com

⚠️ **注意**: 首次登录后请立即修改默认密码！

## 使用方法

### 1. 在Controller中使用权限注解

```java
import org.springframework.security.access.prepost.PreAuthorize;

@RestController
@RequestMapping("/api/users")
public class UserController {

    // 只有拥有 user:read 权限的用户可以访问
    @PreAuthorize("hasAuthority('user:read')")
    @GetMapping
    public List<User> getUsers() {
        // ...
    }

    // 只有超级管理员可以访问
    @PreAuthorize("hasRole('ROLE_SUPER_ADMIN')")
    @PostMapping
    public User createUser(@RequestBody UserDto userDto) {
        // ...
    }

    // 拥有 user:update 权限或超级管理员可以访问
    @PreAuthorize("hasAuthority('user:update') or hasRole('ROLE_SUPER_ADMIN')")
    @PutMapping("/{id}")
    public User updateUser(@PathVariable Long id, @RequestBody UserDto userDto) {
        // ...
    }
}
```

### 2. 在Service层使用权限工具类

```java
import com.star.swiftSecurity.utils.SecurityUtils;
import com.star.swiftSecurity.constant.AuthorityConstants;

@Service
public class BusinessService {

    public void doSomething() {
        // 检查当前用户是否是超级管理员
        if (SecurityUtils.isSuperAdmin()) {
            // 超级管理员可以执行的操作
        }
        
        // 检查当前用户是否拥有特定权限
        if (SecurityUtils.hasPermission(AuthorityConstants.DATA_READ)) {
            // 有权限的操作
        }
        
        // 检查是否可以访问资源（超级管理员自动通过）
        if (SecurityUtils.canAccess(AuthorityConstants.DATA_DELETE)) {
            // 执行删除操作
        }
        
        // 获取当前登录用户
        var currentUser = SecurityUtils.getCurrentUser();
        if (currentUser != null) {
            String username = currentUser.getUsername();
            // ...
        }
    }
}
```

### 3. 在前端传递权限信息

```java
@GetMapping("/api/user/info")
public ResponseEntity<Map<String, Object>> getUserInfo() {
    SwiftUserDetails user = SecurityUtils.getCurrentUser();
    Map<String, Object> result = new HashMap<>();
    
    result.put("userId", user.getUserId());
    result.put("username", user.getUsername());
    result.put("fullName", user.getFullName());
    result.put("email", user.getEmail());
    
    // 获取用户的所有权限
    List<String> permissions = user.getAuthorities().stream()
            .map(GrantedAuthority::getAuthority)
            .collect(Collectors.toList());
    result.put("permissions", permissions);
    
    // 判断是否是超级管理员
    result.put("isSuperAdmin", SecurityUtils.isSuperAdmin());
    
    return ResponseEntity.ok(result);
}
```

### 4. 自定义角色和权限

如果需要添加新的角色或权限，可以参考以下步骤：

#### 添加新角色

```java
// 在 RoleConstants.java 中添加
public static final String ROLE_MANAGER = "ROLE_MANAGER";
public static final String ROLE_MANAGER_DESC = "管理员，拥有部分管理权限";
```

#### 添加新权限

```java
// 在 AuthorityConstants.java 中添加
public static final String REPORT_READ = "report:read";
public static final String REPORT_READ_DESC = "查看报表";
```

#### 在初始化器中创建

```java
// 在 SecurityDataInitializer.java 的 initRoles() 方法中
createRoleIfNotExists(RoleConstants.ROLE_MANAGER, RoleConstants.ROLE_MANAGER_DESC);

// 在 initAuthorities() 方法中
createAuthorityIfNotExists(AuthorityConstants.REPORT_READ, AuthorityConstants.REPORT_READ_DESC);

// 在 assignAuthoritiesToRoles() 方法中
SwiftRole managerRole = roleMapper.findByName(RoleConstants.ROLE_MANAGER);
if (managerRole != null) {
    // 为管理员角色分配权限
    grantAuthorityToRole(managerRole, AuthorityConstants.REPORT_READ);
}
```

## 数据库表结构

权限管理模块包含以下核心表：

- `swift_users`: 用户表
- `swift_roles`: 角色表
- `swift_authorities`: 权限表
- `swift_user_roles`: 用户角色关联表
- `swift_role_authorities`: 角色权限关联表

## 初始化数据

### 自动初始化

应用启动时会自动执行 `SecurityDataInitializer`，初始化所有角色和权限数据。

### 手动初始化

也可以手动执行 SQL 脚本初始化数据：

```bash
mysql -u root -p your_database < swift-start/src/main/resources/security-data.sql
```

## 最佳实践

1. **使用注解进行权限控制**: 在 Controller 层使用 `@PreAuthorize` 注解进行方法级别的权限控制
2. **使用工具类进行业务逻辑判断**: 在 Service 层使用 `SecurityUtils` 进行业务逻辑中的权限判断
3. **权限粒度适中**: 权限粒度不宜过细，也不宜过粗，根据实际业务需求设计
4. **定期审查权限**: 定期审查用户权限，及时清理不必要的权限
5. **修改默认密码**: 首次登录后立即修改默认密码
6. **使用超级管理员谨慎**: 超级管理员拥有所有权限，使用时要格外小心

## 安全建议

1. 生产环境必须修改默认用户密码
2. 避免在代码中硬编码密码
3. 使用强密码策略
4. 启用账户锁定机制（已默认启用）
5. 定期备份用户和权限数据
6. 记录敏感操作的审计日志

## 技术支持

如有问题，请参考源代码或提交 Issue。
