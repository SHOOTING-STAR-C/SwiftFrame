# 登录查询性能优化说明

## 问题描述

每次登录时会发生两次大量调用数据库查询的问题，严重影响系统性能。

## 问题分析

### 第一次查询链路（发生在 JWT 过滤器中）

1. `JwtAuthenticationFilter.doFilterInternal()` → `userDetailsService.loadUserByUserId(userId)`
2. `SwiftUserServiceImpl.loadUserByUserId()` → `getUserById(userId)`
3. 如果缓存未命中，调用 `userMapper.findByIdWithAuthorities(userId)`
4. **N+1 查询问题**：
   - 查询用户信息 (1次)
   - MyBatis 延迟加载触发：
     - 查询用户角色关系 (N次，每个角色1次)
     - 查询每个角色的详情 (N次)
     - 查询每个角色的权限关系 (M次)
     - 查询每个权限的详情 (M次)

### 第二次查询链路（发生在缓存写入时）

1. `getUserById()` 查询完成后，调用 `userCacheService.cacheUser()`
2. `UserCacheServiceImpl.cacheUser()` 中调用 `user.getUserRoles()` 提取权限信息
3. 由于 MyBatis 延迟加载，**再次触发相同的查询链路**

### 举例说明

如果一个用户有：
- 2个角色
- 每个角色有3个权限

则会触发：
- 用户查询：1次
- 角色关系查询：2次
- 角色详情查询：2次
- 权限关系查询：6次
- 权限详情查询：6次

总计：17次数据库查询（第一次查询链路）

缓存写入时再次触发：17次数据库查询（第二次查询链路）

**总计：34次数据库查询**

## 优化方案

### 1. 优化的 JOIN 查询

在 `SwiftUserMapper.xml` 中修改了 `findByIdWithAuthorities` 方法，使用 JOIN 一次性获取所有数据：

```xml
<select id="findByIdWithAuthorities" resultMap="UserResultMap">
    SELECT 
        u.user_id, u.username, u.full_name, u.password, u.email, u.phone, u.enabled,
        u.account_non_expired, u.account_non_locked, u.credentials_non_expired,
        u.failed_login_attempts, u.lock_until, u.password_changed_at, u.last_login_at, 
        u.last_login_ip, u.created_at,
        r.role_id, r.name as role_name, r.description as role_description,
        ra.granted_at,
        a.authority_id, a.name as authority_name, a.description as authority_description
    FROM swift_users u
    LEFT JOIN swift_user_roles ur ON u.user_id = ur.user_id
    LEFT JOIN swift_roles r ON ur.role_id = r.role_id
    LEFT JOIN swift_role_authorities ra ON r.role_id = ra.role_id
    LEFT JOIN swift_authorities a ON ra.authority_id = a.authority_id
    WHERE u.user_id = #{userId}
</select>
```

### 2. 优化的 ResultMap

修改了 `UserResultMap`，避免了使用嵌套 `select`，直接在一次查询中获取所有数据：

```xml
<resultMap id="UserResultMap" type="com.star.swiftSecurity.entity.SwiftUserDetails">
    <id property="userId" column="user_id" javaType="java.lang.Long"/>
    <result property="username" column="username"/>
    <!-- ... 其他用户字段 ... -->
    
    <!-- 角色和权限信息 -->
    <collection property="userRoles" ofType="com.star.swiftSecurity.entity.SwiftUserRole">
        <result property="userId.userId" column="user_id"/>
        <result property="userId.roleId" column="role_id"/>
        <result property="assignedAt" column="granted_at"/>
        <association property="role" javaType="com.star.swiftSecurity.entity.SwiftRole">
            <id property="roleId" column="role_id" javaType="java.lang.Long"/>
            <result property="name" column="role_name"/>
            <result property="description" column="role_description"/>
            <collection property="roleAuthorities" ofType="com.star.swiftSecurity.entity.SwiftRoleAuthority">
                <result property="id.roleId" column="role_id"/>
                <result property="id.authorityId" column="authority_id"/>
                <result property="grantedAt" column="granted_at"/>
                <association property="authority" javaType="com.star.swiftSecurity.entity.SwiftAuthority">
                    <id property="authorityId" column="authority_id" javaType="java.lang.Long"/>
                    <result property="name" column="authority_name"/>
                    <result property="description" column="authority_description"/>
                </association>
            </collection>
        </association>
    </collection>
</resultMap>
```

### 3. 更新 Mapper 接口

在 `SwiftUserMapper.java` 中更新了方法注释：

```java
/**
 * 根据ID查找用户（包含角色权限）
 * 使用JOIN一次性获取所有数据，避免N+1查询问题
 */
SwiftUserDetails findByIdWithAuthorities(@Param("userId") Long userId);
```

### 4. Service 实现无需修改

`SwiftUserServiceImpl.java` 中的 `getUserById()` 方法已经正确使用了 `findByIdWithAuthorities()`，无需修改。

## 优化效果

### 优化前
- 首次登录：34次数据库查询
- 后续登录（缓存命中）：0次数据库查询

### 优化后
- 首次登录：**1次数据库查询**
- 后续登录（缓存命中）：0次数据库查询

### 性能提升
- 查询次数减少：**97%** (34次 → 1次)
- 响应时间大幅降低
- 数据库负载显著减少

## 技术细节

### 为什么之前会有 N+1 查询？

1. **MyBatis 延迟加载**：原 `UserResultMap` 使用了嵌套的 `select`：
   ```xml
   <collection property="userRoles" ofType="com.star.swiftSecurity.entity.SwiftUserRole"
               select="com.star.swiftSecurity.mapper.mysql.SwiftUserRoleMapper.findByUser" column="user_id"/>
   ```

2. **延迟加载机制**：MyBatis 不会立即执行嵌套查询，而是在访问属性时才执行

3. **多次触发**：
   - 第一次：JWT 过滤器加载用户时触发
   - 第二次：缓存服务提取权限信息时再次触发

### JOIN 查询的优势

1. **一次性获取**：使用 LEFT JOIN 在一次查询中获取所有相关数据
2. **避免延迟加载**：ResultMap 直接映射结果，无需额外的 select
3. **数据一致性**：确保所有数据在同一事务中读取，避免不一致
4. **性能显著提升**：减少数据库往返次数

## 注意事项

1. **缓存优先**：优化后仍然优先使用 Redis 缓存，只有在缓存未命中时才会执行数据库查询
2. **数据一致性**：JOIN 查询确保了数据的一致性，避免了多次查询期间数据变化的问题
3. **索引优化**：建议为以下字段添加索引以进一步提升性能：
   - `swift_users.user_id` (主键，已有索引)
   - `swift_user_roles.user_id`
   - `swift_user_roles.role_id`
   - `swift_role_authorities.role_id`
   - `swift_role_authorities.authority_id`

## 测试建议

1. **功能测试**：
   - 测试用户登录流程
   - 验证权限加载是否正确
   - 检查缓存写入和读取

2. **性能测试**：
   - 监控数据库查询日志，确认查询次数已减少
   - 测试不同配置的用户（不同角色和权限数量）
   - 压力测试，验证性能提升效果

3. **数据库监控**：
   - 观察慢查询日志
   - 监控数据库连接池使用情况
   - 检查 JOIN 查询的执行计划

## 相关文件

- `swift-security/src/main/resources/sqlmapper/mysql/SwiftUserMapper.xml` - 优化的查询和 ResultMap
- `swift-security/src/main/java/com/star/swiftSecurity/mapper/mysql/SwiftUserMapper.java` - Mapper 接口
- `swift-security/src/main/java/com/star/swiftSecurity/service/impl/SwiftUserServiceImpl.java` - Service 实现
- `swift-security/src/main/java/com/star/swiftSecurity/filter/JwtAuthenticationFilter.java` - JWT 过滤器
- `swift-security/src/main/java/com/star/swiftSecurity/service/impl/UserCacheServiceImpl.java` - 缓存服务

## 总结

通过将 MyBatis 的嵌套 select 查询改为 JOIN 查询，成功解决了登录时的 N+1 查询问题，将数据库查询次数从 34 次减少到 1 次，性能提升 97%。这是一个典型的 ORM 框架性能优化案例，展示了如何通过合理的查询设计来避免常见的性能陷阱。
